package jp.co.sample.framework.test.dto.assertj;

import jp.co.sample.framework.test.dto.MulitpleTypeDto;
import org.assertj.core.api.AbstractObjectAssert;
import org.assertj.core.api.Assertions;
import org.assertj.core.internal.Iterables;
import org.assertj.core.util.Objects;

/**
 * Abstract base class for {@link MulitpleTypeDto} specific assertions - Generated by CustomAssertionGenerator.
 */
@javax.annotation.Generated(value="assertj-assertions-generator")
public abstract class AbstractMulitpleTypeDtoAssert<S extends AbstractMulitpleTypeDtoAssert<S, A>, A extends MulitpleTypeDto> extends AbstractObjectAssert<S, A> {

  /**
   * Creates a new <code>{@link AbstractMulitpleTypeDtoAssert}</code> to make assertions on actual MultipleTypeDto.
   * @param actual the MultipleTypeDto we want to make assertions on.
   */
  protected AbstractMulitpleTypeDtoAssert(A actual, Class<S> selfType) {
    super(actual, selfType);
  }

  /**
   * Verifies that the actual MultipleTypeDto's arrayValue contains the given String elements.
   * @param arrayValue the given elements that should be contained in actual MultipleTypeDto's arrayValue.
   * @return this assertion object.
   * @throws AssertionError if the actual MultipleTypeDto's arrayValue does not contain all given String elements.
   */
  public S hasArrayValue(String... arrayValue) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // check that given String varargs is not null.
    if (arrayValue == null) failWithMessage("Expecting arrayValue parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.getArrayValue()).contains(arrayValue);

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto's arrayValue contains <b>only</b> the given String elements and nothing else in whatever order.
   *
   * @param arrayValue the given elements that should be contained in actual MultipleTypeDto's arrayValue.
   * @return this assertion object.
   * @throws AssertionError if the actual MultipleTypeDto's arrayValue does not contain all given String elements and nothing else.
   */
  public S hasOnlyArrayValue(String... arrayValue) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // check that given String varargs is not null.
    if (arrayValue == null) failWithMessage("Expecting arrayValue parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.getArrayValue()).containsOnly(arrayValue);

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto's arrayValue does not contain the given String elements.
   *
   * @param arrayValue the given elements that should not be in actual MultipleTypeDto's arrayValue.
   * @return this assertion object.
   * @throws AssertionError if the actual MultipleTypeDto's arrayValue contains any given String elements.
   */
  public S doesNotHaveArrayValue(String... arrayValue) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // check that given String varargs is not null.
    if (arrayValue == null) failWithMessage("Expecting arrayValue parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Assertions.assertThat(actual.getArrayValue()).doesNotContain(arrayValue);

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto has no arrayValue.
   * @return this assertion object.
   * @throws AssertionError if the actual MultipleTypeDto's arrayValue is not empty.
   */
  public S hasNoArrayValue() {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have arrayValue but had :\n  <%s>";

    // check that it is not empty
    if (actual.getArrayValue().length > 0)  {
      failWithMessage(assertjErrorMessage, actual, java.util.Arrays.toString(actual.getArrayValue()));
    }

    // return the current assertion for method chaining
    return myself;
  }


  /**
   * Verifies that the actual MultipleTypeDto's bigDecimalValue is equal to the given one.
   * @param bigDecimalValue the given bigDecimalValue to compare the actual MultipleTypeDto's bigDecimalValue to.
   * @return this assertion object.
   * @throws AssertionError - if the actual MultipleTypeDto's bigDecimalValue is not equal to the given one.
   */
  public S hasBigDecimalValue(java.math.BigDecimal bigDecimalValue) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting bigDecimalValue of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // null safe check
    java.math.BigDecimal actualBigDecimalValue = actual.getBigDecimalValue();
    if (!Objects.areEqual(actualBigDecimalValue, bigDecimalValue)) {
      failWithMessage(assertjErrorMessage, actual, bigDecimalValue, actualBigDecimalValue);
    }

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto is boolean value.
   * @return this assertion object.
   * @throws AssertionError - if the actual MultipleTypeDto is not boolean value.
   */
  public S isBooleanValue() {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // check that property call/field access is true
    if (!actual.isBooleanValue()) {
      failWithMessage("\nExpecting that actual MultipleTypeDto is boolean value but is not.");
    }

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto is not boolean value.
   * @return this assertion object.
   * @throws AssertionError - if the actual MultipleTypeDto is boolean value.
   */
  public S isNotBooleanValue() {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // check that property call/field access is false
    if (actual.isBooleanValue()) {
      failWithMessage("\nExpecting that actual MultipleTypeDto is not boolean value but is.");
    }

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto's booleanWrapperValue is equal to the given one.
   * @param booleanWrapperValue the given booleanWrapperValue to compare the actual MultipleTypeDto's booleanWrapperValue to.
   * @return this assertion object.
   * @throws AssertionError - if the actual MultipleTypeDto's booleanWrapperValue is not equal to the given one.
   */
  public S hasBooleanWrapperValue(Boolean booleanWrapperValue) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting booleanWrapperValue of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // null safe check
    Boolean actualBooleanWrapperValue = actual.getBooleanWrapperValue();
    if (!Objects.areEqual(actualBooleanWrapperValue, booleanWrapperValue)) {
      failWithMessage(assertjErrorMessage, actual, booleanWrapperValue, actualBooleanWrapperValue);
    }

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto's byteValue is equal to the given one.
   * @param byteValue the given byteValue to compare the actual MultipleTypeDto's byteValue to.
   * @return this assertion object.
   * @throws AssertionError - if the actual MultipleTypeDto's byteValue is not equal to the given one.
   */
  public S hasByteValue(byte byteValue) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting byteValue of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // check
    byte actualByteValue = actual.getByteValue();
    if (actualByteValue != byteValue) {
      failWithMessage(assertjErrorMessage, actual, byteValue, actualByteValue);
    }

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto's byteWrapperValue is equal to the given one.
   * @param byteWrapperValue the given byteWrapperValue to compare the actual MultipleTypeDto's byteWrapperValue to.
   * @return this assertion object.
   * @throws AssertionError - if the actual MultipleTypeDto's byteWrapperValue is not equal to the given one.
   */
  public S hasByteWrapperValue(Byte byteWrapperValue) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting byteWrapperValue of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // null safe check
    Byte actualByteWrapperValue = actual.getByteWrapperValue();
    if (!Objects.areEqual(actualByteWrapperValue, byteWrapperValue)) {
      failWithMessage(assertjErrorMessage, actual, byteWrapperValue, actualByteWrapperValue);
    }

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto's charValue is equal to the given one.
   * @param charValue the given charValue to compare the actual MultipleTypeDto's charValue to.
   * @return this assertion object.
   * @throws AssertionError - if the actual MultipleTypeDto's charValue is not equal to the given one.
   */
  public S hasCharValue(char charValue) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting charValue of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // check charValue char matches
    char actualCharValue = actual.getCharValue();
    if (actualCharValue != charValue) {
      failWithMessage(assertjErrorMessage, actual, charValue, actualCharValue);
    }

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto's charWrapperValue is equal to the given one.
   * @param charWrapperValue the given charWrapperValue to compare the actual MultipleTypeDto's charWrapperValue to.
   * @return this assertion object.
   * @throws AssertionError - if the actual MultipleTypeDto's charWrapperValue is not equal to the given one.
   */
  public S hasCharWrapperValue(Character charWrapperValue) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting charWrapperValue of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // null safe check
    Character actualCharWrapperValue = actual.getCharWrapperValue();
    if (!Objects.areEqual(actualCharWrapperValue, charWrapperValue)) {
      failWithMessage(assertjErrorMessage, actual, charWrapperValue, actualCharWrapperValue);
    }

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto's codeValue is equal to the given one.
   * @param codeValue the given codeValue to compare the actual MultipleTypeDto's codeValue to.
   * @return this assertion object.
   * @throws AssertionError - if the actual MultipleTypeDto's codeValue is not equal to the given one.
   */
  public S hasCodeValue(jp.co.sample.common.code.CodeVo codeValue) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting codeValue of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // null safe check
    jp.co.sample.common.code.CodeVo actualCodeValue = actual.getCodeValue();
    if (!Objects.areEqual(actualCodeValue, codeValue)) {
      failWithMessage(assertjErrorMessage, actual, codeValue, actualCodeValue);
    }

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto's dateValue is equal to the given one.
   * @param dateValue the given dateValue to compare the actual MultipleTypeDto's dateValue to.
   * @return this assertion object.
   * @throws AssertionError - if the actual MultipleTypeDto's dateValue is not equal to the given one.
   */
  public S hasDateValue(java.util.Date dateValue) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting dateValue of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // null safe check
    java.util.Date actualDateValue = actual.getDateValue();
    if (!Objects.areEqual(actualDateValue, dateValue)) {
      failWithMessage(assertjErrorMessage, actual, dateValue, actualDateValue);
    }

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto's doubleValue is equal to the given one.
   * @param doubleValue the given doubleValue to compare the actual MultipleTypeDto's doubleValue to.
   * @return this assertion object.
   * @throws AssertionError - if the actual MultipleTypeDto's doubleValue is not equal to the given one.
   */
  public S hasDoubleValue(double doubleValue) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting doubleValue of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // check value for doubleValue
    double actualDoubleValue = actual.getDoubleValue();
    if (actualDoubleValue != doubleValue) {
      failWithMessage(assertjErrorMessage, actual, doubleValue, actualDoubleValue);
    }

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto's doubleValue is close to the given value by less than the given offset.
   * <p>
   * If difference is equal to the offset value, assertion is considered successful.
   * @param doubleValue the value to compare the actual MultipleTypeDto's doubleValue to.
   * @param assertjOffset the given offset.
   * @return this assertion object.
   * @throws AssertionError - if the actual MultipleTypeDto's doubleValue is not close enough to the given value.
   */
  public S hasDoubleValueCloseTo(double doubleValue, double assertjOffset) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    double actualDoubleValue = actual.getDoubleValue();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = String.format("\nExpecting doubleValue:\n  <%s>\nto be close to:\n  <%s>\nby less than <%s> but difference was <%s>",
                                               actualDoubleValue, doubleValue, assertjOffset, Math.abs(doubleValue - actualDoubleValue));

    // check
    Assertions.assertThat(actualDoubleValue).overridingErrorMessage(assertjErrorMessage).isCloseTo(doubleValue, Assertions.within(assertjOffset));

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto's doubleWrapperValue is equal to the given one.
   * @param doubleWrapperValue the given doubleWrapperValue to compare the actual MultipleTypeDto's doubleWrapperValue to.
   * @return this assertion object.
   * @throws AssertionError - if the actual MultipleTypeDto's doubleWrapperValue is not equal to the given one.
   */
  public S hasDoubleWrapperValue(Double doubleWrapperValue) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting doubleWrapperValue of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // null safe check
    Double actualDoubleWrapperValue = actual.getDoubleWrapperValue();
    if (!Objects.areEqual(actualDoubleWrapperValue, doubleWrapperValue)) {
      failWithMessage(assertjErrorMessage, actual, doubleWrapperValue, actualDoubleWrapperValue);
    }

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto's doubleWrapperValue is close to the given value by less than the given offset.
   * <p>
   * If difference is equal to the offset value, assertion is considered successful.
   * @param doubleWrapperValue the value to compare the actual MultipleTypeDto's doubleWrapperValue to.
   * @param assertjOffset the given offset.
   * @return this assertion object.
   * @throws AssertionError - if the actual MultipleTypeDto's doubleWrapperValue is not close enough to the given value.
   */
  public S hasDoubleWrapperValueCloseTo(Double doubleWrapperValue, Double assertjOffset) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    Double actualDoubleWrapperValue = actual.getDoubleWrapperValue();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = String.format("\nExpecting doubleWrapperValue:\n  <%s>\nto be close to:\n  <%s>\nby less than <%s> but difference was <%s>",
                                               actualDoubleWrapperValue, doubleWrapperValue, assertjOffset, Math.abs(doubleWrapperValue - actualDoubleWrapperValue));

    // check
    Assertions.assertThat(actualDoubleWrapperValue).overridingErrorMessage(assertjErrorMessage).isCloseTo(doubleWrapperValue, Assertions.within(assertjOffset));

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto's floatValue is equal to the given one.
   * @param floatValue the given floatValue to compare the actual MultipleTypeDto's floatValue to.
   * @return this assertion object.
   * @throws AssertionError - if the actual MultipleTypeDto's floatValue is not equal to the given one.
   */
  public S hasFloatValue(float floatValue) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting floatValue of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // check value for floatValue
    float actualFloatValue = actual.getFloatValue();
    if (actualFloatValue != floatValue) {
      failWithMessage(assertjErrorMessage, actual, floatValue, actualFloatValue);
    }

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto's floatValue is close to the given value by less than the given offset.
   * <p>
   * If difference is equal to the offset value, assertion is considered successful.
   * @param floatValue the value to compare the actual MultipleTypeDto's floatValue to.
   * @param assertjOffset the given offset.
   * @return this assertion object.
   * @throws AssertionError - if the actual MultipleTypeDto's floatValue is not close enough to the given value.
   */
  public S hasFloatValueCloseTo(float floatValue, float assertjOffset) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    float actualFloatValue = actual.getFloatValue();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = String.format("\nExpecting floatValue:\n  <%s>\nto be close to:\n  <%s>\nby less than <%s> but difference was <%s>",
                                               actualFloatValue, floatValue, assertjOffset, Math.abs(floatValue - actualFloatValue));

    // check
    Assertions.assertThat(actualFloatValue).overridingErrorMessage(assertjErrorMessage).isCloseTo(floatValue, Assertions.within(assertjOffset));

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto's floatWrapperValue is equal to the given one.
   * @param floatWrapperValue the given floatWrapperValue to compare the actual MultipleTypeDto's floatWrapperValue to.
   * @return this assertion object.
   * @throws AssertionError - if the actual MultipleTypeDto's floatWrapperValue is not equal to the given one.
   */
  public S hasFloatWrapperValue(Float floatWrapperValue) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting floatWrapperValue of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // null safe check
    Float actualFloatWrapperValue = actual.getFloatWrapperValue();
    if (!Objects.areEqual(actualFloatWrapperValue, floatWrapperValue)) {
      failWithMessage(assertjErrorMessage, actual, floatWrapperValue, actualFloatWrapperValue);
    }

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto's floatWrapperValue is close to the given value by less than the given offset.
   * <p>
   * If difference is equal to the offset value, assertion is considered successful.
   * @param floatWrapperValue the value to compare the actual MultipleTypeDto's floatWrapperValue to.
   * @param assertjOffset the given offset.
   * @return this assertion object.
   * @throws AssertionError - if the actual MultipleTypeDto's floatWrapperValue is not close enough to the given value.
   */
  public S hasFloatWrapperValueCloseTo(Float floatWrapperValue, Float assertjOffset) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    Float actualFloatWrapperValue = actual.getFloatWrapperValue();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = String.format("\nExpecting floatWrapperValue:\n  <%s>\nto be close to:\n  <%s>\nby less than <%s> but difference was <%s>",
                                               actualFloatWrapperValue, floatWrapperValue, assertjOffset, Math.abs(floatWrapperValue - actualFloatWrapperValue));

    // check
    Assertions.assertThat(actualFloatWrapperValue).overridingErrorMessage(assertjErrorMessage).isCloseTo(floatWrapperValue, Assertions.within(assertjOffset));

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto's intValue is equal to the given one.
   * @param intValue the given intValue to compare the actual MultipleTypeDto's intValue to.
   * @return this assertion object.
   * @throws AssertionError - if the actual MultipleTypeDto's intValue is not equal to the given one.
   */
  public S hasIntValue(int intValue) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting intValue of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // check
    int actualIntValue = actual.getIntValue();
    if (actualIntValue != intValue) {
      failWithMessage(assertjErrorMessage, actual, intValue, actualIntValue);
    }

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto's intWrapperValue is equal to the given one.
   * @param intWrapperValue the given intWrapperValue to compare the actual MultipleTypeDto's intWrapperValue to.
   * @return this assertion object.
   * @throws AssertionError - if the actual MultipleTypeDto's intWrapperValue is not equal to the given one.
   */
  public S hasIntWrapperValue(Integer intWrapperValue) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting intWrapperValue of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // null safe check
    Integer actualIntWrapperValue = actual.getIntWrapperValue();
    if (!Objects.areEqual(actualIntWrapperValue, intWrapperValue)) {
      failWithMessage(assertjErrorMessage, actual, intWrapperValue, actualIntWrapperValue);
    }

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto's listValue contains the given String elements.
   * @param listValue the given elements that should be contained in actual MultipleTypeDto's listValue.
   * @return this assertion object.
   * @throws AssertionError if the actual MultipleTypeDto's listValue does not contain all given String elements.
   */
  public S hasListValue(String... listValue) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // check that given String varargs is not null.
    if (listValue == null) failWithMessage("Expecting listValue parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.getListValue(), listValue);

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto's listValue contains the given String elements in Collection.
   * @param listValue the given elements that should be contained in actual MultipleTypeDto's listValue.
   * @return this assertion object.
   * @throws AssertionError if the actual MultipleTypeDto's listValue does not contain all given String elements.
   */
  public S hasListValue(java.util.Collection<? extends String> listValue) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // check that given String collection is not null.
    if (listValue == null) {
      failWithMessage("Expecting listValue parameter not to be null.");
      return myself; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.getListValue(), listValue.toArray());

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto's listValue contains <b>only</b> the given String elements and nothing else in whatever order.
   * @param listValue the given elements that should be contained in actual MultipleTypeDto's listValue.
   * @return this assertion object.
   * @throws AssertionError if the actual MultipleTypeDto's listValue does not contain all given String elements.
   */
  public S hasOnlyListValue(String... listValue) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // check that given String varargs is not null.
    if (listValue == null) failWithMessage("Expecting listValue parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.getListValue(), listValue);

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto's listValue contains <b>only</b> the given String elements in Collection and nothing else in whatever order.
   * @param listValue the given elements that should be contained in actual MultipleTypeDto's listValue.
   * @return this assertion object.
   * @throws AssertionError if the actual MultipleTypeDto's listValue does not contain all given String elements.
   */
  public S hasOnlyListValue(java.util.Collection<? extends String> listValue) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // check that given String collection is not null.
    if (listValue == null) {
      failWithMessage("Expecting listValue parameter not to be null.");
      return myself; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.getListValue(), listValue.toArray());

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto's listValue does not contain the given String elements.
   *
   * @param listValue the given elements that should not be in actual MultipleTypeDto's listValue.
   * @return this assertion object.
   * @throws AssertionError if the actual MultipleTypeDto's listValue contains any given String elements.
   */
  public S doesNotHaveListValue(String... listValue) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // check that given String varargs is not null.
    if (listValue == null) failWithMessage("Expecting listValue parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.getListValue(), listValue);

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto's listValue does not contain the given String elements in Collection.
   *
   * @param listValue the given elements that should not be in actual MultipleTypeDto's listValue.
   * @return this assertion object.
   * @throws AssertionError if the actual MultipleTypeDto's listValue contains any given String elements.
   */
  public S doesNotHaveListValue(java.util.Collection<? extends String> listValue) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // check that given String collection is not null.
    if (listValue == null) {
      failWithMessage("Expecting listValue parameter not to be null.");
      return myself; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.getListValue(), listValue.toArray());

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto has no listValue.
   * @return this assertion object.
   * @throws AssertionError if the actual MultipleTypeDto's listValue is not empty.
   */
  public S hasNoListValue() {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have listValue but had :\n  <%s>";

    // check
    if (actual.getListValue().iterator().hasNext()) {
      failWithMessage(assertjErrorMessage, actual, actual.getListValue());
    }

    // return the current assertion for method chaining
    return myself;
  }


  /**
   * Verifies that the actual MultipleTypeDto's localDateTimeValue is equal to the given one.
   * @param localDateTimeValue the given localDateTimeValue to compare the actual MultipleTypeDto's localDateTimeValue to.
   * @return this assertion object.
   * @throws AssertionError - if the actual MultipleTypeDto's localDateTimeValue is not equal to the given one.
   */
  public S hasLocalDateTimeValue(java.time.LocalDateTime localDateTimeValue) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting localDateTimeValue of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // null safe check
    java.time.LocalDateTime actualLocalDateTimeValue = actual.getLocalDateTimeValue();
    if (!Objects.areEqual(actualLocalDateTimeValue, localDateTimeValue)) {
      failWithMessage(assertjErrorMessage, actual, localDateTimeValue, actualLocalDateTimeValue);
    }

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto's localDateValue is equal to the given one.
   * @param localDateValue the given localDateValue to compare the actual MultipleTypeDto's localDateValue to.
   * @return this assertion object.
   * @throws AssertionError - if the actual MultipleTypeDto's localDateValue is not equal to the given one.
   */
  public S hasLocalDateValue(java.time.LocalDate localDateValue) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting localDateValue of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // null safe check
    java.time.LocalDate actualLocalDateValue = actual.getLocalDateValue();
    if (!Objects.areEqual(actualLocalDateValue, localDateValue)) {
      failWithMessage(assertjErrorMessage, actual, localDateValue, actualLocalDateValue);
    }

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto's localTimeValue is equal to the given one.
   * @param localTimeValue the given localTimeValue to compare the actual MultipleTypeDto's localTimeValue to.
   * @return this assertion object.
   * @throws AssertionError - if the actual MultipleTypeDto's localTimeValue is not equal to the given one.
   */
  public S hasLocalTimeValue(java.time.LocalTime localTimeValue) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting localTimeValue of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // null safe check
    java.time.LocalTime actualLocalTimeValue = actual.getLocalTimeValue();
    if (!Objects.areEqual(actualLocalTimeValue, localTimeValue)) {
      failWithMessage(assertjErrorMessage, actual, localTimeValue, actualLocalTimeValue);
    }

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto's longValue is equal to the given one.
   * @param longValue the given longValue to compare the actual MultipleTypeDto's longValue to.
   * @return this assertion object.
   * @throws AssertionError - if the actual MultipleTypeDto's longValue is not equal to the given one.
   */
  public S hasLongValue(long longValue) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting longValue of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // check
    long actualLongValue = actual.getLongValue();
    if (actualLongValue != longValue) {
      failWithMessage(assertjErrorMessage, actual, longValue, actualLongValue);
    }

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto's longWrapperValue is equal to the given one.
   * @param longWrapperValue the given longWrapperValue to compare the actual MultipleTypeDto's longWrapperValue to.
   * @return this assertion object.
   * @throws AssertionError - if the actual MultipleTypeDto's longWrapperValue is not equal to the given one.
   */
  public S hasLongWrapperValue(Long longWrapperValue) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting longWrapperValue of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // null safe check
    Long actualLongWrapperValue = actual.getLongWrapperValue();
    if (!Objects.areEqual(actualLongWrapperValue, longWrapperValue)) {
      failWithMessage(assertjErrorMessage, actual, longWrapperValue, actualLongWrapperValue);
    }

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto's mapValue is equal to the given one.
   * @param mapValue the given mapValue to compare the actual MultipleTypeDto's mapValue to.
   * @return this assertion object.
   * @throws AssertionError - if the actual MultipleTypeDto's mapValue is not equal to the given one.
   */
  public S hasMapValue(java.util.Map mapValue) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting mapValue of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // null safe check
    java.util.Map actualMapValue = actual.getMapValue();
    if (!Objects.areEqual(actualMapValue, mapValue)) {
      failWithMessage(assertjErrorMessage, actual, mapValue, actualMapValue);
    }

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto's setValue contains the given String elements.
   * @param setValue the given elements that should be contained in actual MultipleTypeDto's setValue.
   * @return this assertion object.
   * @throws AssertionError if the actual MultipleTypeDto's setValue does not contain all given String elements.
   */
  public S hasSetValue(String... setValue) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // check that given String varargs is not null.
    if (setValue == null) failWithMessage("Expecting setValue parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.getSetValue(), setValue);

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto's setValue contains the given String elements in Collection.
   * @param setValue the given elements that should be contained in actual MultipleTypeDto's setValue.
   * @return this assertion object.
   * @throws AssertionError if the actual MultipleTypeDto's setValue does not contain all given String elements.
   */
  public S hasSetValue(java.util.Collection<? extends String> setValue) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // check that given String collection is not null.
    if (setValue == null) {
      failWithMessage("Expecting setValue parameter not to be null.");
      return myself; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContains(info, actual.getSetValue(), setValue.toArray());

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto's setValue contains <b>only</b> the given String elements and nothing else in whatever order.
   * @param setValue the given elements that should be contained in actual MultipleTypeDto's setValue.
   * @return this assertion object.
   * @throws AssertionError if the actual MultipleTypeDto's setValue does not contain all given String elements.
   */
  public S hasOnlySetValue(String... setValue) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // check that given String varargs is not null.
    if (setValue == null) failWithMessage("Expecting setValue parameter not to be null.");

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.getSetValue(), setValue);

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto's setValue contains <b>only</b> the given String elements in Collection and nothing else in whatever order.
   * @param setValue the given elements that should be contained in actual MultipleTypeDto's setValue.
   * @return this assertion object.
   * @throws AssertionError if the actual MultipleTypeDto's setValue does not contain all given String elements.
   */
  public S hasOnlySetValue(java.util.Collection<? extends String> setValue) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // check that given String collection is not null.
    if (setValue == null) {
      failWithMessage("Expecting setValue parameter not to be null.");
      return myself; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
    Iterables.instance().assertContainsOnly(info, actual.getSetValue(), setValue.toArray());

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto's setValue does not contain the given String elements.
   *
   * @param setValue the given elements that should not be in actual MultipleTypeDto's setValue.
   * @return this assertion object.
   * @throws AssertionError if the actual MultipleTypeDto's setValue contains any given String elements.
   */
  public S doesNotHaveSetValue(String... setValue) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // check that given String varargs is not null.
    if (setValue == null) failWithMessage("Expecting setValue parameter not to be null.");

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.getSetValue(), setValue);

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto's setValue does not contain the given String elements in Collection.
   *
   * @param setValue the given elements that should not be in actual MultipleTypeDto's setValue.
   * @return this assertion object.
   * @throws AssertionError if the actual MultipleTypeDto's setValue contains any given String elements.
   */
  public S doesNotHaveSetValue(java.util.Collection<? extends String> setValue) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // check that given String collection is not null.
    if (setValue == null) {
      failWithMessage("Expecting setValue parameter not to be null.");
      return myself; // to fool Eclipse "Null pointer access" warning on toArray.
    }

    // check with standard error message (use overridingErrorMessage before contains to set your own message).
    Iterables.instance().assertDoesNotContain(info, actual.getSetValue(), setValue.toArray());

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto has no setValue.
   * @return this assertion object.
   * @throws AssertionError if the actual MultipleTypeDto's setValue is not empty.
   */
  public S hasNoSetValue() {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // we override the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have setValue but had :\n  <%s>";

    // check
    if (actual.getSetValue().iterator().hasNext()) {
      failWithMessage(assertjErrorMessage, actual, actual.getSetValue());
    }

    // return the current assertion for method chaining
    return myself;
  }


  /**
   * Verifies that the actual MultipleTypeDto's shortValue is equal to the given one.
   * @param shortValue the given shortValue to compare the actual MultipleTypeDto's shortValue to.
   * @return this assertion object.
   * @throws AssertionError - if the actual MultipleTypeDto's shortValue is not equal to the given one.
   */
  public S hasShortValue(short shortValue) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting shortValue of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // check
    short actualShortValue = actual.getShortValue();
    if (actualShortValue != shortValue) {
      failWithMessage(assertjErrorMessage, actual, shortValue, actualShortValue);
    }

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto's shortWrapperValue is equal to the given one.
   * @param shortWrapperValue the given shortWrapperValue to compare the actual MultipleTypeDto's shortWrapperValue to.
   * @return this assertion object.
   * @throws AssertionError - if the actual MultipleTypeDto's shortWrapperValue is not equal to the given one.
   */
  public S hasShortWrapperValue(Short shortWrapperValue) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting shortWrapperValue of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // null safe check
    Short actualShortWrapperValue = actual.getShortWrapperValue();
    if (!Objects.areEqual(actualShortWrapperValue, shortWrapperValue)) {
      failWithMessage(assertjErrorMessage, actual, shortWrapperValue, actualShortWrapperValue);
    }

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto's stringValue is equal to the given one.
   * @param stringValue the given stringValue to compare the actual MultipleTypeDto's stringValue to.
   * @return this assertion object.
   * @throws AssertionError - if the actual MultipleTypeDto's stringValue is not equal to the given one.
   */
  public S hasStringValue(String stringValue) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting stringValue of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // null safe check
    String actualStringValue = actual.getStringValue();
    if (!Objects.areEqual(actualStringValue, stringValue)) {
      failWithMessage(assertjErrorMessage, actual, stringValue, actualStringValue);
    }

    // return the current assertion for method chaining
    return myself;
  }

  /**
   * Verifies that the actual MultipleTypeDto's timestampValue is equal to the given one.
   * @param timestampValue the given timestampValue to compare the actual MultipleTypeDto's timestampValue to.
   * @return this assertion object.
   * @throws AssertionError - if the actual MultipleTypeDto's timestampValue is not equal to the given one.
   */
  public S hasTimestampValue(java.sql.Timestamp timestampValue) {
    // check that actual MultipleTypeDto we want to make assertions on is not null.
    isNotNull();

    // overrides the default error message with a more explicit one
    String assertjErrorMessage = "\nExpecting timestampValue of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

    // null safe check
    java.sql.Timestamp actualTimestampValue = actual.getTimestampValue();
    if (!Objects.areEqual(actualTimestampValue, timestampValue)) {
      failWithMessage(assertjErrorMessage, actual, timestampValue, actualTimestampValue);
    }

    // return the current assertion for method chaining
    return myself;
  }

}
